{"pages":[{"text":"When I attended college I observed some people around me that became satisfied with their status quo. They felt they had learned enough and that was the enough for them. They felt they knew everything they needed to know. Maybe that was hubris, maybe it was laziness, I'm not quite sure. The word I used was stagnation. I knew I wanted to avoid at all costs. This has stuck with me to this day, but I've continued to evolve it by adding on little mental hacks and mantras as I went. I try to do what I can to keep hubris at bay because I've found it to be one of the warning signs of heading down an ill-fated path. One of the things that's befuddled me in recent years is the concept of things that are the \"best\" or variations therof. In the software world one of the most common bests are Best Practices and I've seen a lot of them come and go. They're the best...for a while...then they're gone. Maybe we should call the \"Best for Now Practices,\" but it's not as catchy. I have a strong belief that \"best practices\" in the absolute sense will always be elusive. Mostly because of the human factor. There's always going to be something we don't understand fully, something we misunderstand, or something we just plain did wrong. That leads we to that saying that I've crafted over the last few years that flips traditional thinking on its head: \"I've only found a slightly less worse way of doing things.\" Now, that's doesn't mean I think everything I do is absolute garbage. In fact, I'm very proud of all the work I've done having not been traditionally educated in computer science. I say that because it forces you to assume a certain measure of fallibility in yourself. I've found that thinking you're infallible is the express bus to screwing up. You're no longer willing to look for mistakes in what you do and nature will step in and remind you that you're human (or at least it'll give it the old college try). It also means you constantly strive for improvement because you're always striving for better. You seek it out not because you're fed up with something, but because you know it's out there and you want it because it makes you better. Another gain from this is that every mistake is an opportunity for improvement. I'm a big proponent of learning from your mistakes and making sure you have the opportunity to make those mistakes in a safe environment (by safe, I don't just mean free from harm to others but also free from shaming those who screw up). Lastly, it's an acknowledgement of entropy in our lives. Things break down. What used to work doesn't work anymore or at least not as well. Knowledge becomes outdated and needs refreshing. You need refreshing.","tags":"Software","loc":"http://rhysyngsun.com/slightly-less-worse-ways.html","title":"Slightly Less Worse Ways"},{"text":"I've spent the last 10 months working with AWS' CloudFormation service. I felt it would be useful to put my thoughts together on how I found the service to be for a small startup. Pros CloudFormation is great if you don't want to deal with the orchestration of your deployments. It runs over your configuration files and figures out what the delta changes are, applies them taking dependencies into account, and will also rollback if a failure occurs. Overall, CloudFormation works well for offloading the execution of deployments. Cons There are a few places where CloudFormation begins to fall short for me. The first is complexity. I'm not saying the service can't handle the complexity, but humans can't handle the complexity of the JSON that CloudFormation uses for configuration. Even a moderately complex environment can begin to clock in at thousands of lines of JSON. At that point, it starts to feel like the XML days of yore. That means you have to lean on a tool like troposphere can do some heavy lifting. Troposphere is a great library and I would not even try to approach CloudFormation without it or something equivalent. The second downside is when your stacks fail to rollback. This happens most often when you're making a complicated change (e.g. refactoring nested CloudFormation templates) and the only way to get resolution on it is to contact AWS support. Support on the forums is slow and you're not always guaranteed to get attention either so if you end up using CloudFormation you better have premium support . Your best bet is to makes a series of smaller, incremental changes, rather than sweeping refactoring. The third downside is that you're limited to 20 stacks per region by default. You can request an increase to this limit, but there's always a limit. Limits like this are in place so that AWS can ensure a performant service for all their customers. This ends up steering you towards monolithic stacks, which can be even more painful. This also makes it much more difficult to run an arbitrary number of ad-hoc production-like environments for your developers. Alternatives Roll Your Own with Boto If you're using Python to generate CloudFormation configuration, it's not a huge leap to just use boto directly. The AWS CLI runs on boto so the one thing you can count on is really solid service coverage. Boto will give you much more control and a better ability to recover from failed deployments, whereas a failure in CloudFormation (failed rollbacks are notoriously painful and always require intervention of AWS support to resolve) can possibly hold your service hostage while you engage AWS support to fix the failed stack. You'll have to handle rollback yourself, but you have much control over how exactly that works. Terraform Hashicorp's Terraform is one project to keep an eye on. The main roadblock to adoption for me would be the limited scope of AWS coverage . It's a pretty cool tool so far though and once it achieves a higher coverage of AWS services it will probably be my go-to tool. Final Thoughts CloudFormation can really help you get going on AWS if you don't want to deal with some of the deployment logistics, but the complexity of configuring it will quickly catch up with you for non-trivial deployments. AWS is continuing to improve the service though so some of the pitfalls I point out here may improve of time (particularly the rollback failures as I know it's a sore point).","tags":"AWS","loc":"http://rhysyngsun.com/thoughts-on-cloudformation.html","title":"Thoughts on CloudFormation"},{"text":"I've spent the last week looking at various CI solutions. My main criteria were: create a flexible Continuous Delivery deployment pipeline ability to promote builds to various environments (QA, prod, etc) alerting to our team It started with an attempt at wrangling the defacto tool, Jenkins into a usable system but that quickly proved to be an uphill battle. Overly complication configuration aside, the final straw with Jenkins was being unable to configure GitHub Web Hooks , however that capability was dependent on having GitHub configured as the authentication method for users. That's a pretty flawed design that speaks to a poor separation of concerns; authentication strategy should not be tangled with an unrelated feature of the product. Overall, I think the legacy of Jenkins' plugin architecture is weighing it (and its users) down. I also took a look at numerous open source competitors to Jenkins as well as SaaS-based solutions. Pretty much all of these fell short on Goal #2, which lead to me a conclusion that everyone out there either: is deploying code straight into production via automation (Continuous Deployment) poured weeks of developer time into Jenkins gave up on Jenkins and rolled a custom solution I wasn't ready to commit to any of these at the immediate moment, so the situation was looking pretty bleak. I threw out a tweet to vent my frustration at the state of CI/CD solutions. Chad Wathington replied that ThoughtWorks had recently open sourced their Continuous Delivery solution named Go (not to be confused with Golang, an issue they're acutely aware of ). So far, I'm pretty impressed. As far as open source self-hostable CI solutions go, it's not nearing an complicated and limiting as Jenkins. It does seem a tad more complicated than I need, but it's likely because my initial pass at getting a pipeline is intended to be a simple one. I still feel like Go is needs a lot of work and hope to contribute to it myself at some point (although I wish it wasn't written in Java). I've also got feeling that I should take a stab at my own solution (to be done on my own time, not my employer's). There's a lot to still be done in this space and I have a gut feeling that it needs a fresh approach that incorporates all these learnings. The fresh start is needed because an ideal solution for CI needs back pressure against complexity.","tags":"Continuous Integration","loc":"http://rhysyngsun.com/my-ideal-continuous-integration-server.html","title":"My Ideal Continuous Integration Server"},{"text":"I'm a huge fan of keeping code complexity to a minimum. Note that I'm distinguishing code complexity from system complexity. I believe you can have a complex system built on simple code. In fact, that's what you want because such code is highly testable. We've all run across examples of complex code: a class with too many concerns, a function that's doing too many operations, or an abstraction in a place where it's unnecessary. A few days after his passing, I watched a video of Jim Weirich of Rake fame giving a presentation on the concept of connascence . I highly recommend you watch it if you're unfamiliar with the topic. This topic really hit on one of those things that I'd previously vaguely categorized as a \"code smell.\" Code that's highly coupled makes for painful points when you have to change a behavior in the overall system. It's nice to have a quality metric for that now. A few days later it struck me that this concept explains very well why I've always had trouble with this style of RequireJS (this example lifted from their docs here : //my/shirt.js now has some dependencies, a cart and inventory //module in the same directory as shirt.js define ([ \"./cart\" , \"./inventory\" ], function ( cart , inventory ) { //return an object to define the \"my/shirt\" module. return { color : \"blue\" , size : \"large\" , addToCart : function () { inventory . decrement ( this ); cart . add ( this ); } } }); In this example, there's an increasing Connascence of Order between the array of dependencies and the argument list as the number of dependencies for your module increase. Ideally, you should be keeping your dependency count as low as possible, but very often it slips over two or three, which is the point at which I'd say this type of connascence starts to become troublesome. I'm also one of those folks who is very anal with making sure dependencies/imports are logically ordered and (if necessary) logically grouped. That means I'm occasionally inserting a dependency into list, rather than appending it. Note that there's also a Connascence of Name between a dependency's name in the list and the filename of that module. There's no way to get away from that, but you can completely remove the Connascence of Order by changing to a CommonJS-ish style: define ( function ( require ) { //my/shirt.js now has some dependencies, a cart and inventory //module in the same directory as shirt.js var cart = require ( \"./cart\" ), inventory = require ( \"./inventory\" ); //return an object to define the \"my/shirt\" module. return { color : \"blue\" , size : \"large\" , addToCart : function () { inventory . decrement ( this ); cart . add ( this ); } } }); The CommonJS style eliminates a whole class of programmer error. Sure you might have a few extra lines of code, but you've removed the need for the mental overhead of making sure the order is right in both places.","tags":"Software Engineering","loc":"http://rhysyngsun.com/connascence-in-requirejs.html","title":"Connascence in RequireJS"},{"text":"A few days ago I was trying to integrate the twitter-bootstrap Grails plugin into an app but was having difficulty getting the less sources to play nice with the lesscss-resources plugin. It turned out that the most recent version of bootstrap used LessCSS syntax that is only available in the 1.3.3 version of the lesscss compiler. The lesscss-resources depends on version 1.3.1, so to work around that issue you can update your BuildConfig.groovy settings to the following to force a specific version of the lesscss compiler: grails . project . dependency . resolution = { dependencies { runtime ( 'org.lesscss:lesscss:1.3.3' ) } plugins { compile ( \":lesscss-resources:1.3.1\" ) { excludes \"lesscss\" } } }","tags":"JVM","loc":"http://rhysyngsun.com/grails-using-a-specific-version-of-lesscss-with-lesscss-resources.html","title":"Grails - Using a specific version of LessCSS with lesscss-resources"},{"text":"I've spent some time this weekend working on an entry for Mozilla's Dev Derby . You can find my entry hosted on the competition site . This is my first entry so please, go ahead and vote for it. I also noted today before I submitted my entry that I'm not the only one who thought to make a clock . It's interesting to see our our visuals, animations, and implementations differ. How I Did It I've this entry available as a GitHub repo so you can browse the source yourself. I wanted this to be a relatively quick weekend project and fun to do. A requirement of the competition is for it to work across various browsers, so I started with Sass and Compass to deal with generating a lot of the yuck that comes with browser specific code (particularly vendor-prefixed CSS). Sass was also very useful in generating the animations. Just compare the Sass source (55 lines) and the generated CSS (1914 lines) to get an idea of how painful and impossible this would have been to do in a weekend. Getting the hands of the clock was relatively straightforward. The difficult part was in positioning the Roman numerals. In order for those numerals to fit correctly in the ring around the edge, they had to be rotated individually around the center of the clock face. Additionally the overall set of numerals for a given hour had to be approximately centered on the radius line for that hour. The combination of those two pretty much ruled out positioning individual characters as a sane strategy. Instead, I opted for grouping the numerals (wrapping in <span> tags) in a parent <div> and rotating that <div> around the center. I then individually tweaked the characters by rotating them around the same point in smaller increments. I also created guides to help me align the numerals on the radius lines. You can see it commented out on line 39 here . All in all it took me about 8-10 hours over the weekend to create this. Most of that time was spent playing with css tranforms. I'll definitely putting in an entry for August as that contest is near and dear to my heart . </shameless-plug>","tags":"CSS","loc":"http://rhysyngsun.com/mozilla-dev-derby-july.html","title":"Mozilla Dev Derby July"},{"text":"This is my first time playing with building a Jekyll-based site for GitHub Pages . In the past I've used Wordpress and then Posterous, but with obvious recent events that wasn't going to be good for the long term. I honestly only ever wrote a single \"First Post\" on posterous, because I didn't have any personal investment in the site. I had previously got sick of the maintenence around Wordpress (not to mention the PHP) and moved to Posterous for simplicity. I feel Jekyll/GHP balances my desire for simplicity with my need for control when I need it.","tags":"Site News","loc":"http://rhysyngsun.com/from-posterous-to-jekyll-and-github-pages.html","title":"From Posterous to Jekyll and GitHub Pages"}]}